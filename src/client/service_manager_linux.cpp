#if defined(__linux__)

#include "service_manager.hpp"
#include "common/logger.hpp"

#include <cstdlib>
#include <fstream>
#include <sstream>
#include <array>
#include <unistd.h>

namespace edgelink::client {

namespace {
auto& log() { return Logger::get("service"); }

constexpr const char* SERVICE_NAME = "edgelink-client";
constexpr const char* DISPLAY_NAME = "EdgeLink Client";

// 执行命令并获取输出
std::pair<int, std::string> exec_command(const std::string& cmd) {
    std::array<char, 128> buffer;
    std::string result;
    FILE* pipe = popen((cmd + " 2>&1").c_str(), "r");
    if (!pipe) {
        return {-1, "Failed to execute command"};
    }
    while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {
        result += buffer.data();
    }
    int status = pclose(pipe);
    return {WEXITSTATUS(status), result};
}

// 检查是否是 root 用户
bool is_root() {
    return geteuid() == 0;
}

}

std::string ServiceManager::last_error_;

std::string ServiceManager::service_name() {
    return SERVICE_NAME;
}

std::string ServiceManager::display_name() {
    return DISPLAY_NAME;
}

const std::string& ServiceManager::last_error() {
    return last_error_;
}

bool ServiceManager::is_installed() {
    return is_installed_systemd();
}

bool ServiceManager::is_running() {
    return is_running_systemd();
}

ServiceStatus ServiceManager::status() {
    return status_systemd();
}

bool ServiceManager::install(const std::filesystem::path& exe_path) {
    return install_systemd(exe_path);
}

bool ServiceManager::uninstall() {
    return uninstall_systemd();
}

bool ServiceManager::start() {
    return start_systemd();
}

bool ServiceManager::stop() {
    return stop_systemd();
}

// ============================================================================
// Linux systemd Implementation
// ============================================================================

std::filesystem::path ServiceManager::unit_file_path() {
    if (is_root()) {
        return std::filesystem::path("/etc/systemd/system") / (std::string(SERVICE_NAME) + ".service");
    } else {
        // 用户模式
        const char* config_home = std::getenv("XDG_CONFIG_HOME");
        if (config_home) {
            return std::filesystem::path(config_home) / "systemd/user" / (std::string(SERVICE_NAME) + ".service");
        }
        const char* home = std::getenv("HOME");
        if (home) {
            return std::filesystem::path(home) / ".config/systemd/user" / (std::string(SERVICE_NAME) + ".service");
        }
        return std::filesystem::path("/etc/systemd/system") / (std::string(SERVICE_NAME) + ".service");
    }
}

std::string ServiceManager::generate_unit_file(const std::filesystem::path& exe_path) {
    std::ostringstream oss;

    oss << "# EdgeLink Client systemd service\n"
        << "# Generated by edgelink-client\n"
        << "\n"
        << "[Unit]\n"
        << "Description=" << DISPLAY_NAME << "\n"
        << "After=network-online.target\n"
        << "Wants=network-online.target\n"
        << "\n"
        << "[Service]\n"
        << "Type=simple\n"
        << "ExecStart=" << exe_path.string() << " daemon\n"
        << "Restart=always\n"
        << "RestartSec=5\n"
        << "StandardOutput=journal\n"
        << "StandardError=journal\n";

    if (is_root()) {
        // 系统服务设置
        oss << "User=root\n"
            << "Group=root\n";
    }

    oss << "\n"
        << "[Install]\n"
        << "WantedBy=";

    if (is_root()) {
        oss << "multi-user.target\n";
    } else {
        oss << "default.target\n";
    }

    return oss.str();
}

bool ServiceManager::is_installed_systemd() {
    auto unit_path = unit_file_path();
    return std::filesystem::exists(unit_path);
}

bool ServiceManager::is_running_systemd() {
    std::string cmd = is_root()
        ? "systemctl is-active " + std::string(SERVICE_NAME)
        : "systemctl --user is-active " + std::string(SERVICE_NAME);

    auto [status, output] = exec_command(cmd);
    return status == 0;
}

ServiceStatus ServiceManager::status_systemd() {
    if (!is_installed_systemd()) {
        return ServiceStatus::NOT_INSTALLED;
    }

    std::string cmd = is_root()
        ? "systemctl is-active " + std::string(SERVICE_NAME)
        : "systemctl --user is-active " + std::string(SERVICE_NAME);

    auto [status, output] = exec_command(cmd);

    // 去除末尾换行
    while (!output.empty() && (output.back() == '\n' || output.back() == '\r')) {
        output.pop_back();
    }

    if (output == "active" || output == "activating") {
        return ServiceStatus::RUNNING;
    } else if (output == "inactive" || output == "deactivating" || output == "failed") {
        return ServiceStatus::STOPPED;
    }

    return ServiceStatus::UNKNOWN;
}

bool ServiceManager::install_systemd(const std::filesystem::path& exe_path) {
    auto unit_path = unit_file_path();

    // 确保目录存在
    auto unit_dir = unit_path.parent_path();
    std::error_code ec;
    if (!std::filesystem::exists(unit_dir)) {
        std::filesystem::create_directories(unit_dir, ec);
        if (ec) {
            last_error_ = "Failed to create directory: " + unit_dir.string() + " - " + ec.message();
            return false;
        }
    }

    // 检查写入权限
    if (is_root()) {
        // 系统模式需要 root 权限
        if (!is_root()) {
            last_error_ = "Root privileges required to install system service";
            return false;
        }
    }

    // 生成并写入 unit 文件
    std::string unit_content = generate_unit_file(exe_path);

    std::ofstream ofs(unit_path);
    if (!ofs) {
        last_error_ = "Failed to write unit file: " + unit_path.string();
        return false;
    }
    ofs << unit_content;
    ofs.close();

    log().info("Created systemd unit file: {}", unit_path.string());

    // 重新加载 systemd 配置
    std::string cmd = is_root()
        ? "systemctl daemon-reload"
        : "systemctl --user daemon-reload";

    auto [status, output] = exec_command(cmd);
    if (status != 0) {
        last_error_ = "Failed to reload systemd: " + output;
        return false;
    }

    // 启用开机自启
    cmd = is_root()
        ? "systemctl enable " + std::string(SERVICE_NAME)
        : "systemctl --user enable " + std::string(SERVICE_NAME);

    auto [status2, output2] = exec_command(cmd);
    if (status2 != 0) {
        log().warn("Failed to enable service: {}", output2);
        // 不算失败，继续
    }

    log().info("Service installed successfully");
    return true;
}

bool ServiceManager::uninstall_systemd() {
    auto unit_path = unit_file_path();

    // 先停止服务
    stop_systemd();

    // 禁用开机自启
    std::string cmd = is_root()
        ? "systemctl disable " + std::string(SERVICE_NAME)
        : "systemctl --user disable " + std::string(SERVICE_NAME);

    exec_command(cmd);  // 忽略错误

    // 删除 unit 文件
    if (std::filesystem::exists(unit_path)) {
        std::error_code ec;
        std::filesystem::remove(unit_path, ec);
        if (ec) {
            last_error_ = "Failed to remove unit file: " + ec.message();
            return false;
        }
    }

    // 重新加载 systemd 配置
    cmd = is_root()
        ? "systemctl daemon-reload"
        : "systemctl --user daemon-reload";

    exec_command(cmd);

    log().info("Service uninstalled successfully");
    return true;
}

bool ServiceManager::start_systemd() {
    if (!is_installed_systemd()) {
        last_error_ = "Service is not installed";
        return false;
    }

    std::string cmd = is_root()
        ? "systemctl start " + std::string(SERVICE_NAME)
        : "systemctl --user start " + std::string(SERVICE_NAME);

    auto [status, output] = exec_command(cmd);
    if (status != 0) {
        last_error_ = "Failed to start service: " + output;
        return false;
    }

    // 验证服务是否真的启动了
    for (int i = 0; i < 10; ++i) {
        if (is_running_systemd()) {
            log().info("Service started successfully");
            return true;
        }
        usleep(500000);  // 0.5 秒
    }

    last_error_ = "Service failed to start";
    return false;
}

bool ServiceManager::stop_systemd() {
    if (!is_installed_systemd()) {
        last_error_ = "Service is not installed";
        return true;  // 不存在也算成功
    }

    std::string cmd = is_root()
        ? "systemctl stop " + std::string(SERVICE_NAME)
        : "systemctl --user stop " + std::string(SERVICE_NAME);

    auto [status, output] = exec_command(cmd);
    if (status != 0) {
        // 可能服务已经停止了
        if (!is_running_systemd()) {
            return true;
        }
        last_error_ = "Failed to stop service: " + output;
        return false;
    }

    log().info("Service stopped successfully");
    return true;
}

} // namespace edgelink::client

#endif // __linux__
